Application	Application.cpp	/^Application::Application(char *infile) {$/;"	f	class:Application
fail	Application.cpp	/^void Application::fail() {$/;"	f	class:Application
getjoinaddr	Application.cpp	/^Address Application::getjoinaddr(void){$/;"	f	class:Application
handler	Application.cpp	/^void handler(int sig) {$/;"	f
main	Application.cpp	/^int main(int argc, char *argv[]) {$/;"	f
mp1Run	Application.cpp	/^void Application::mp1Run() {$/;"	f	class:Application
run	Application.cpp	/^int Application::run()$/;"	f	class:Application
~Application	Application.cpp	/^Application::~Application() {$/;"	f	class:Application
ARGS_COUNT	Application.h	26;"	d
Application	Application.h	/^class Application{$/;"	c
JOINADDR	Application.h	/^	char JOINADDR[30];$/;"	m	class:Application
TOTAL_RUNNING_TIME	Application.h	27;"	d
_APPLICATION_H_	Application.h	8;"	d
en	Application.h	/^	EmulNet *en;$/;"	m	class:Application
log	Application.h	/^    Log *log;$/;"	m	class:Application
mp1	Application.h	/^	MP1Node **mp1;$/;"	m	class:Application
nodeCount	Application.h	/^int nodeCount = 0;$/;"	v
par	Application.h	/^	Params *par;$/;"	m	class:Application
ENcleanup	EmulNet.cpp	/^int EmulNet::ENcleanup() {$/;"	f	class:EmulNet
ENinit	EmulNet.cpp	/^void *EmulNet::ENinit(Address *myaddr, short port) {$/;"	f	class:EmulNet
ENrecv	EmulNet.cpp	/^int EmulNet::ENrecv(Address *myaddr, int (* enq)(void *, char *, int), struct timeval *t, int times, void *queue){$/;"	f	class:EmulNet
ENsend	EmulNet.cpp	/^int EmulNet::ENsend(Address *myaddr, Address *toaddr, char *data, int size) {$/;"	f	class:EmulNet
ENsend	EmulNet.cpp	/^int EmulNet::ENsend(Address *myaddr, Address *toaddr, string data) {$/;"	f	class:EmulNet
EmulNet	EmulNet.cpp	/^EmulNet::EmulNet(EmulNet &anotherEmulNet) {$/;"	f	class:EmulNet
EmulNet	EmulNet.cpp	/^EmulNet::EmulNet(Params *p)$/;"	f	class:EmulNet
operator =	EmulNet.cpp	/^EmulNet& EmulNet::operator =(EmulNet &anotherEmulNet) {$/;"	f	class:EmulNet
~EmulNet	EmulNet.cpp	/^EmulNet::~EmulNet() {}$/;"	f	class:EmulNet
EM	EmulNet.h	/^	EM() {}$/;"	f	class:EM
EM	EmulNet.h	/^class EM {$/;"	c
ENBUFFSIZE	EmulNet.h	12;"	d
EmulNet	EmulNet.h	/^class EmulNet$/;"	c
MAX_NODES	EmulNet.h	10;"	d
MAX_TIME	EmulNet.h	11;"	d
_EMULNET_H_	EmulNet.h	8;"	d
buff	EmulNet.h	/^	en_msg* buff[ENBUFFSIZE];$/;"	m	class:EM
currbuffsize	EmulNet.h	/^	int currbuffsize;$/;"	m	class:EM
emulnet	EmulNet.h	/^	EM emulnet;$/;"	m	class:EmulNet
enInited	EmulNet.h	/^	int enInited;$/;"	m	class:EmulNet
en_msg	EmulNet.h	/^typedef struct en_msg {$/;"	s
en_msg	EmulNet.h	/^}en_msg;$/;"	t	typeref:struct:en_msg
firsteltindex	EmulNet.h	/^	int firsteltindex;$/;"	m	class:EM
from	EmulNet.h	/^	Address from;$/;"	m	struct:en_msg
getCurrBuffSize	EmulNet.h	/^	int getCurrBuffSize() {$/;"	f	class:EM
getFirstEltIndex	EmulNet.h	/^	int getFirstEltIndex() {$/;"	f	class:EM
getNextId	EmulNet.h	/^	int getNextId() {$/;"	f	class:EM
nextid	EmulNet.h	/^	int nextid;$/;"	m	class:EM
operator =	EmulNet.h	/^	EM& operator = (EM &anotherEM) {$/;"	f	class:EM
par	EmulNet.h	/^	Params* par;$/;"	m	class:EmulNet
recv_msgs	EmulNet.h	/^	int recv_msgs[MAX_NODES + 1][MAX_TIME];$/;"	m	class:EmulNet
sent_msgs	EmulNet.h	/^	int sent_msgs[MAX_NODES + 1][MAX_TIME];$/;"	m	class:EmulNet
setFirstEltIndex	EmulNet.h	/^	void setFirstEltIndex(int firsteltindex) {$/;"	f	class:EM
setNextId	EmulNet.h	/^	void setNextId(int nextid) {$/;"	f	class:EM
settCurrBuffSize	EmulNet.h	/^	void settCurrBuffSize(int currbuffsize) {$/;"	f	class:EM
size	EmulNet.h	/^	int size;$/;"	m	struct:en_msg
to	EmulNet.h	/^	Address to;$/;"	m	struct:en_msg
~EM	EmulNet.h	/^	virtual ~EM() {}$/;"	f	class:EM
contains	Grader.sh	/^function contains () {$/;"	f
LOG	Log.cpp	/^void Log::LOG(Address *addr, const char * str, ...) {$/;"	f	class:Log
Log	Log.cpp	/^Log::Log(Params *p) {$/;"	f	class:Log
Log	Log.cpp	/^Log::Log(const Log &anotherLog) {$/;"	f	class:Log
logNodeAdd	Log.cpp	/^void Log::logNodeAdd(Address *thisNode, Address *addedAddr) {$/;"	f	class:Log
logNodeRemove	Log.cpp	/^void Log::logNodeRemove(Address *thisNode, Address *removedAddr) {$/;"	f	class:Log
operator =	Log.cpp	/^Log& Log::operator = (const Log& anotherLog) {$/;"	f	class:Log
~Log	Log.cpp	/^Log::~Log() {}$/;"	f	class:Log
DBG_LOG	Log.h	20;"	d
Log	Log.h	/^class Log{$/;"	c
MAGIC_NUMBER	Log.h	19;"	d
MAXWRITES	Log.h	18;"	d
STATS_LOG	Log.h	21;"	d
_LOG_H_	Log.h	8;"	d
firstTime	Log.h	/^	bool firstTime;$/;"	m	class:Log
par	Log.h	/^	Params *par;$/;"	m	class:Log
MP1Node	MP1Node.cpp	/^MP1Node::MP1Node(Member *member, Params *params, EmulNet *emul, Log *log, Address *address) {$/;"	f	class:MP1Node
checkMessages	MP1Node.cpp	/^void MP1Node::checkMessages() {$/;"	f	class:MP1Node
enqueueWrapper	MP1Node.cpp	/^int MP1Node::enqueueWrapper(void *env, char *buff, int size) {$/;"	f	class:MP1Node
finishUpThisNode	MP1Node.cpp	/^int MP1Node::finishUpThisNode(){$/;"	f	class:MP1Node
getJoinAddress	MP1Node.cpp	/^Address MP1Node::getJoinAddress() {$/;"	f	class:MP1Node
initMemberListTable	MP1Node.cpp	/^void MP1Node::initMemberListTable(Member *memberNode) {$/;"	f	class:MP1Node
initThisNode	MP1Node.cpp	/^int MP1Node::initThisNode(Address *joinaddr) {$/;"	f	class:MP1Node
introduceSelfToGroup	MP1Node.cpp	/^int MP1Node::introduceSelfToGroup(Address *joinaddr) {$/;"	f	class:MP1Node
isNullAddress	MP1Node.cpp	/^int MP1Node::isNullAddress(Address *addr) {$/;"	f	class:MP1Node
nodeLoop	MP1Node.cpp	/^void MP1Node::nodeLoop() {$/;"	f	class:MP1Node
nodeLoopOps	MP1Node.cpp	/^void MP1Node::nodeLoopOps() {$/;"	f	class:MP1Node
nodeStart	MP1Node.cpp	/^void MP1Node::nodeStart(char *servaddrstr, short servport) {$/;"	f	class:MP1Node
printAddress	MP1Node.cpp	/^void MP1Node::printAddress(Address *addr)$/;"	f	class:MP1Node
recvCallBack	MP1Node.cpp	/^bool MP1Node::recvCallBack(void *env, char *data, int size ) {$/;"	f	class:MP1Node
recvLoop	MP1Node.cpp	/^int MP1Node::recvLoop() {$/;"	f	class:MP1Node
~MP1Node	MP1Node.cpp	/^MP1Node::~MP1Node() {}$/;"	f	class:MP1Node
DUMMYLASTMSGTYPE	MP1Node.h	/^    DUMMYLASTMSGTYPE$/;"	e	enum:MsgTypes
JOINREP	MP1Node.h	/^    JOINREP,$/;"	e	enum:MsgTypes
JOINREQ	MP1Node.h	/^    JOINREQ,$/;"	e	enum:MsgTypes
MP1Node	MP1Node.h	/^class MP1Node {$/;"	c
MessageHdr	MP1Node.h	/^typedef struct MessageHdr {$/;"	s
MessageHdr	MP1Node.h	/^}MessageHdr;$/;"	t	typeref:struct:MessageHdr
MsgTypes	MP1Node.h	/^enum MsgTypes{$/;"	g
NULLADDR	MP1Node.h	/^	char NULLADDR[6];$/;"	m	class:MP1Node
TFAIL	MP1Node.h	22;"	d
TREMOVE	MP1Node.h	21;"	d
_MP1NODE_H_	MP1Node.h	9;"	d
emulNet	MP1Node.h	/^	EmulNet *emulNet;$/;"	m	class:MP1Node
getMemberNode	MP1Node.h	/^	Member * getMemberNode() {$/;"	f	class:MP1Node
log	MP1Node.h	/^	Log *log;$/;"	m	class:MP1Node
memberNode	MP1Node.h	/^	Member *memberNode;$/;"	m	class:MP1Node
msgType	MP1Node.h	/^	enum MsgTypes msgType;$/;"	m	struct:MessageHdr	typeref:enum:MessageHdr::MsgTypes
par	MP1Node.h	/^	Params *par;$/;"	m	class:MP1Node
Address	Member.cpp	/^Address::Address(const Address &anotherAddress) {$/;"	f	class:Address
Member	Member.cpp	/^Member::Member(const Member &anotherMember) {$/;"	f	class:Member
MemberListEntry	Member.cpp	/^MemberListEntry::MemberListEntry(const MemberListEntry &anotherMLE) {$/;"	f	class:MemberListEntry
MemberListEntry	Member.cpp	/^MemberListEntry::MemberListEntry(int id, short port): id(id), port(port) {}$/;"	f	class:MemberListEntry
MemberListEntry	Member.cpp	/^MemberListEntry::MemberListEntry(int id, short port, long heartbeat, long timestamp): id(id), port(port), heartbeat(heartbeat), timestamp(timestamp) {}$/;"	f	class:MemberListEntry
getheartbeat	Member.cpp	/^long MemberListEntry::getheartbeat() {$/;"	f	class:MemberListEntry
getid	Member.cpp	/^int MemberListEntry::getid() {$/;"	f	class:MemberListEntry
getport	Member.cpp	/^short MemberListEntry::getport() {$/;"	f	class:MemberListEntry
gettimestamp	Member.cpp	/^long MemberListEntry::gettimestamp() {$/;"	f	class:MemberListEntry
operator =	Member.cpp	/^Address& Address::operator =(const Address& anotherAddress) {$/;"	f	class:Address
operator =	Member.cpp	/^Member& Member::operator =(const Member& anotherMember) {$/;"	f	class:Member
operator =	Member.cpp	/^MemberListEntry& MemberListEntry::operator =(const MemberListEntry &anotherMLE) {$/;"	f	class:MemberListEntry
operator ==	Member.cpp	/^bool Address::operator ==(const Address& anotherAddress) {$/;"	f	class:Address
q_elt	Member.cpp	/^q_elt::q_elt(void *elt, int size): elt(elt), size(size) {}$/;"	f	class:q_elt
setheartbeat	Member.cpp	/^void MemberListEntry::setheartbeat(long hearbeat) {$/;"	f	class:MemberListEntry
setid	Member.cpp	/^void MemberListEntry::setid(int id) {$/;"	f	class:MemberListEntry
setport	Member.cpp	/^void MemberListEntry::setport(short port) {$/;"	f	class:MemberListEntry
settimestamp	Member.cpp	/^void MemberListEntry::settimestamp(long timestamp) {$/;"	f	class:MemberListEntry
Address	Member.h	/^	Address() {}$/;"	f	class:Address
Address	Member.h	/^	Address(string address) {$/;"	f	class:Address
Address	Member.h	/^class Address {$/;"	c
MEMBER_H_	Member.h	8;"	d
Member	Member.h	/^	Member(): inited(false), inGroup(false), bFailed(false), nnb(0), heartbeat(0), pingCounter(0), timeOutCounter(0) {}$/;"	f	class:Member
Member	Member.h	/^class Member {$/;"	c
MemberListEntry	Member.h	/^	MemberListEntry(): id(0), port(0), heartbeat(0), timestamp(0) {}$/;"	f	class:MemberListEntry
MemberListEntry	Member.h	/^class MemberListEntry {$/;"	c
addr	Member.h	/^	Address addr;$/;"	m	class:Member
addr	Member.h	/^	char addr[6];$/;"	m	class:Address
bFailed	Member.h	/^	bool bFailed;$/;"	m	class:Member
elt	Member.h	/^	void *elt;$/;"	m	class:q_elt
getAddress	Member.h	/^	string getAddress() {$/;"	f	class:Address
heartbeat	Member.h	/^	long heartbeat;$/;"	m	class:Member
heartbeat	Member.h	/^	long heartbeat;$/;"	m	class:MemberListEntry
id	Member.h	/^	int id;$/;"	m	class:MemberListEntry
inGroup	Member.h	/^	bool inGroup;$/;"	m	class:Member
init	Member.h	/^	void init() {$/;"	f	class:Address
inited	Member.h	/^	bool inited;$/;"	m	class:Member
memberList	Member.h	/^	vector<MemberListEntry> memberList;$/;"	m	class:Member
mp1q	Member.h	/^	queue<q_elt> mp1q;$/;"	m	class:Member
myPos	Member.h	/^	vector<MemberListEntry>::iterator myPos;$/;"	m	class:Member
nnb	Member.h	/^	int nnb;$/;"	m	class:Member
pingCounter	Member.h	/^	int pingCounter;$/;"	m	class:Member
port	Member.h	/^	short port;$/;"	m	class:MemberListEntry
q_elt	Member.h	/^class q_elt {$/;"	c
size	Member.h	/^	int size;$/;"	m	class:q_elt
timeOutCounter	Member.h	/^	int timeOutCounter;$/;"	m	class:Member
timestamp	Member.h	/^	long timestamp;$/;"	m	class:MemberListEntry
~Member	Member.h	/^	virtual ~Member() {}$/;"	f	class:Member
Params	Params.cpp	/^Params::Params(): PORTNUM(8001) {}$/;"	f	class:Params
getcurrtime	Params.cpp	/^int Params::getcurrtime(){$/;"	f	class:Params
setparams	Params.cpp	/^void Params::setparams(char *config_file) {$/;"	f	class:Params
CREATE_TEST	Params.h	/^enum testTYPE { CREATE_TEST, READ_TEST, UPDATE_TEST, DELETE_TEST };$/;"	e	enum:testTYPE
DELETE_TEST	Params.h	/^enum testTYPE { CREATE_TEST, READ_TEST, UPDATE_TEST, DELETE_TEST };$/;"	e	enum:testTYPE
DROP_MSG	Params.h	/^	int DROP_MSG;$/;"	m	class:Params
EN_GPSZ	Params.h	/^	int EN_GPSZ;			    \/\/ actual number of peers$/;"	m	class:Params
MAX_MSG_SIZE	Params.h	/^	int MAX_MSG_SIZE;$/;"	m	class:Params
MAX_NNB	Params.h	/^	int MAX_NNB;                \/\/ max number of neighbors$/;"	m	class:Params
MSG_DROP_PROB	Params.h	/^	double MSG_DROP_PROB;		\/\/ message drop probability$/;"	m	class:Params
PORTNUM	Params.h	/^	short PORTNUM;$/;"	m	class:Params
Params	Params.h	/^class Params{$/;"	c
READ_TEST	Params.h	/^enum testTYPE { CREATE_TEST, READ_TEST, UPDATE_TEST, DELETE_TEST };$/;"	e	enum:testTYPE
SINGLE_FAILURE	Params.h	/^	int SINGLE_FAILURE;			\/\/ single\/multi failure$/;"	m	class:Params
STEP_RATE	Params.h	/^	double STEP_RATE;		    \/\/ dictates the rate of insertion$/;"	m	class:Params
UPDATE_TEST	Params.h	/^enum testTYPE { CREATE_TEST, READ_TEST, UPDATE_TEST, DELETE_TEST };$/;"	e	enum:testTYPE
_PARAMS_H_	Params.h	8;"	d
allNodesJoined	Params.h	/^	int allNodesJoined;$/;"	m	class:Params
dropmsg	Params.h	/^	int dropmsg;$/;"	m	class:Params
globaltime	Params.h	/^	int globaltime;$/;"	m	class:Params
testTYPE	Params.h	/^enum testTYPE { CREATE_TEST, READ_TEST, UPDATE_TEST, DELETE_TEST };$/;"	g
QUEUE_H_	Queue.h	8;"	d
Queue	Queue.h	/^	Queue() {}$/;"	f	class:Queue
Queue	Queue.h	/^class Queue {$/;"	c
enqueue	Queue.h	/^	static bool enqueue(queue<q_elt> *queue, void *buffer, int size) {$/;"	f	class:Queue
~Queue	Queue.h	/^	virtual ~Queue() {}$/;"	f	class:Queue
DEBUGLOG	stdincludes.h	43;"	d
FAILURE	stdincludes.h	14;"	d
RING_SIZE	stdincludes.h	13;"	d
STDCLLBKARGS	stdincludes.h	41;"	d
STDCLLBKRET	stdincludes.h	42;"	d
SUCCESS	stdincludes.h	15;"	d
_STDINCLUDES_H_	stdincludes.h	8;"	d
NullDevice	submit.py	/^class NullDevice:$/;"	c
StringIO	submit.py	/^import StringIO$/;"	i
URL	submit.py	/^URL = 'cloudcomputing-001'$/;"	v
URL_BASE	submit.py	/^URL_BASE = "https:\/\/class.coursera.org\/"$/;"	v
basicPrompt	submit.py	/^def basicPrompt():$/;"	f
challengeResponse	submit.py	/^def challengeResponse(email, passwd, challenge):$/;"	f
challenge_url	submit.py	/^def challenge_url():$/;"	f
email	submit.py	/^import email$/;"	i
email	submit.py	/^import email.encoders$/;"	i
email	submit.py	/^import email.message$/;"	i
encoders	submit.py	/^import email.encoders$/;"	i
getChallenge	submit.py	/^def getChallenge(email, sid):$/;"	f
hashlib	submit.py	/^import hashlib$/;"	i
loginPrompt	submit.py	/^def loginPrompt():$/;"	f
message	submit.py	/^import email.message$/;"	i
outFiles	submit.py	/^outFiles = ['dbg.log', 'dbg.log', 'dbg.log'] $/;"	v
partFriendlyNames	submit.py	/^partFriendlyNames = ['Single Failure', 'Multiple Failure', 'Message Drop Single Failure'] $/;"	v
partIds	submit.py	/^partIds = ['mp1_part1', 'mp1_part2', 'mp1_part3']$/;"	v
partPrompt	submit.py	/^def partPrompt():$/;"	f
random	submit.py	/^import random$/;"	i
source	submit.py	/^def source(partIdx):$/;"	f
submit	submit.py	/^def submit():   $/;"	f
submitSolution	submit.py	/^def submitSolution(email_address, ch_resp, sid, output, state, ch_aux):$/;"	f
submit_url	submit.py	/^def submit_url():$/;"	f
subprocess	submit.py	/^import subprocess$/;"	i
sys	submit.py	/^import sys$/;"	i
urllib	submit.py	/^import urllib$/;"	i
urllib2	submit.py	/^import urllib2$/;"	i
write	submit.py	/^  def write(self, s):$/;"	m	class:NullDevice
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_PROGRAM_VERSION	5.8	//
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
